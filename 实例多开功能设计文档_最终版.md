# 麦麦启动器实例多开功能设计文档（最终版）

## 功能概述

为麦麦启动器设计了完整的实例多开功能，实现了用户启动完一次实例后，"运行实例"选项自动变为"实例多开"选项，并提供完整的多实例管理功能。**支持多实例种类混用**，允许用户同时运行MaiBot和MoFox_bot实例。

## 核心功能

### 1. 端口管理工具类 (`src/utils/port_manager.py`)

**主要功能：**
- 自动检测系统已使用端口
- 智能分配可用端口，避免冲突
- **支持多实例种类混用**：跨类型端口分配和冲突处理
- 支持多种端口类型：主程序端口、WebUI端口、NapCat端口
- 避免使用系统保留端口

**端口分配策略：**
- **智能扩展**：当首选端口范围冲突时，自动扩展到其他范围
- MaiBot实例：主程序端口(8000-8100) + WebUI端口(8001-8101)
- MoFox_bot实例：主程序端口(8000-8100) + NapCat端口(8090-8190)
- **混用支持**：MaiBot和MoFox_bot实例可以同时运行，端口自动协调

### 2. 实例多开管理器 (`src/modules/instance_multi_launcher.py`)

**主要功能：**
- **灵活配置选择**：创建多开实例时可选择任意已有配置作为基础
- **避免循环引用**：只保存配置名称而非整个配置对象
- 自动配置端口和文件
- 管理实例生命周期（创建、启动、停止、删除）
- **端口使用状态显示**：实时显示当前运行的不同类型实例及其端口
- 实例状态跟踪和显示

**管理操作：**
- **配置选择界面**：显示所有可用配置供用户选择（支持MaiBot和MoFox_bot混用）
- 创建新的多开实例
- 启动/停止指定实例
- 删除不需要的实例
- 查看实例详细信息

### 3. UI动态切换

**菜单显示逻辑：**
- 无活跃实例时：显示"运行实例"
- 有活跃实例时：显示"实例多开"

**相关文件修改：**
- `src/ui/menus.py`：主菜单显示逻辑
- `src/ui/interface.py`：UI接口适配
- `main_refactored.py`：主程序集成逻辑

### 4. 配置文件自动管理

**MaiBot配置：**
- `.env`文件：更新HOST、PORT、WEBUI_PORT等字段
- 适配器config.toml：更新napcat_server和maibot_server端口

**MoFox_bot配置：**
- `.env`文件：更新HOST、PORT字段
- 适配器config.toml：更新napcat_server端口

## 技术实现

### 循环引用问题修复

**问题描述：**
在保存多开实例配置时，直接存储整个配置对象会导致循环引用错误。

**解决方案：**
```python
def create_multi_instance(self, base_config: Dict[str, Any], instance_name: Optional[str] = None) -> str:
    """创建多开实例 - 避免循环引用"""
    # 生成实例ID
    instance_id = str(uuid.uuid4())[:8]
    
    # 配置端口 - 只获取端口信息
    main_port, secondary_port = port_manager.get_next_instance_port(bot_type, base_config)
    
    # 创建多开实例配置 - 避免循环引用，只保存必要的配置信息
    multi_instance = {
        "id": instance_id,
        "name": instance_name,
        "bot_type": bot_type,
        "base_config_name": self._get_config_name_from_config(base_config),  # 保存配置名称
        "created_time": str(Path().cwd()),
        "status": "created",
        "ports": {
            "main_port": main_port,
            "secondary_port": secondary_port
        }
    }
    
    # 保存到多开实例列表
    self.multi_instances[instance_id] = multi_instance
    self._save_multi_instances()
```

**配置获取方法：**
```python
def _get_base_config_for_instance(self, instance: Dict[str, Any]) -> Dict[str, Any]:
    """为多开实例获取基础配置"""
    config_name = instance.get("base_config_name", "")
    if config_name and config_name != "unknown":
        all_configs = config_manager.get_all_configurations()
        base_config = all_configs.get(config_name, {})
    else:
        # 如果没有配置名称，使用默认配置
        base_config = config_manager.get_current_config() or {}
    
    if not base_config:
        raise ValueError("无法获取基础配置")
    
    # 更新端口信息
    ports = instance.get("ports", {})
    main_port = ports.get("main_port")
    secondary_port = ports.get("secondary_port")
    
    # 更新配置文件...
    return base_config
```

### 智能端口分配（支持混用）
```python
def get_next_instance_port(self, instance_type: str, base_config: Dict) -> Tuple[int, int]:
    """为新实例获取下一个可用端口组合，支持多实例混用"""
    if instance_type == "MaiBot":
        # 优先使用mai_main范围，但如果冲突则扩展到其他范围
        try:
            main_port = self.find_available_port("mai_main")
        except:
            main_port = self.find_available_port("mofox_main")  # 扩展搜索
        
        try:
            webui_port = self.find_available_port("mai_webui", main_port + 1)
        except:
            webui_port = self.find_available_port("webui", main_port + 1)  # 扩展搜索
            
        return main_port, webui_port
        
    elif instance_type == "MoFox_bot":
        # 优先使用mofox_main范围，但如果冲突则扩展
        try:
            main_port = self.find_available_port("mofox_main")
        except:
            main_port = self.find_available_port("mai_main")  # 扩展搜索
        
        try:
            napcat_port = self.find_available_port("napcat", main_port + 1)
        except:
            # 如果napcat范围也冲突，使用mai_webui范围
            napcat_port = self.find_available_port("mai_webui", main_port + 1)
            
        return main_port, napcat_port
```

### 灵活配置选择界面
```python
def _handle_create_multi_instance(self):
    """处理创建多开实例 - 支持选择任意配置"""
    # 获取所有可用配置
    all_configurations = config_manager.get_all_configurations()
    
    # 显示所有配置供用户选择
    ui.console.print("请选择要作为基础配置的实例：", style=ui.colors["info"])
    config_list = list(all_configurations.items())
    
    # 创建配置选择表格
    from rich.table import Table
    table = Table(show_header=True, header_style="bold magenta")
    table.add_column("序号", style="dim", width=6)
    table.add_column("配置名称", style="cyan")
    table.add_column("Bot类型", style="yellow")
    table.add_column("版本", style="green")
    table.add_column("昵称", style="blue")
    
    for i, (config_name, config) in enumerate(config_list, 1):
        bot_type = config.get("bot_type", "未知")
        version = config.get("version_path", "未知")
        nickname = config.get("nickname_path", "未知")
        table.add_row(str(i), config_name, bot_type, version, nickname)
    
    ui.console.print(table)
    
    # 用户选择配置
    choice = ui.get_input("请选择配置序号: ").upper()
    # ... 处理选择逻辑
```

### 端口使用状态显示
```python
def _show_port_usage_status(self):
    """显示端口使用状态"""
    # 获取当前运行中的实例
    running_instances = [inst for inst in self.list_multi_instances() if inst["status"] == "running"]
    
    # 按类型分组显示
    mai_instances = [inst for inst in running_instances if inst["bot_type"] == "MaiBot"]
    mofox_instances = [inst for inst in running_instances if inst["bot_type"] == "MoFox_bot"]
    
    if mai_instances:
        ui.console.print("  MaiBot实例:", style=ui.colors["success"])
        for inst in mai_instances:
            ports = inst.get("ports", {})
            main_port = ports.get("main_port", "N/A")
            webui_port = ports.get("secondary_port", "N/A")
            ui.console.print(f"    - {inst['name']}: 主程序({main_port}) + WebUI({webui_port})", style="white")
    
    if mofox_instances:
        ui.console.print("  MoFox_bot实例:", style=ui.colors["success"])
        for inst in mofox_instances:
            ports = inst.get("ports", {})
            main_port = ports.get("main_port", "N/A")
            napcat_port = ports.get("secondary_port", "N/A")
            ui.console.print(f"    - {inst['name']}: 主程序({main_port}) + NapCat({napcat_port})", style="white")
```

## 使用流程

1. **首次启动**：用户选择配置并启动实例
2. **菜单切换**：启动后主菜单"A"选项变为"实例多开"
3. **创建多开**：选择"创建新的多开实例"，系统显示：
   - 所有可用配置列表（支持MaiBot和MoFox_bot）
   - 用户可选择任意配置作为基础
   - 自动分配可用端口（支持混用）
   - 更新配置文件
   - 创建实例记录
4. **管理实例**：可以启动、停止、删除多开实例
5. **混用运行**：可以同时运行MaiBot和MoFox_bot实例，端口自动协调

## 混用场景示例

### 场景1：同时运行不同类型实例
```
运行状态显示：
  MaiBot实例:
    - 实例A: 主程序(8000) + WebUI(8001)
    - 实例B: 主程序(8002) + WebUI(8003)
  MoFox_bot实例:
    - 实例C: 主程序(8004) + NapCat(8090)
    - 实例D: 主程序(8005) + NapCat(8091)
```

### 场景2：端口冲突自动处理
- 如果MaiBot实例占用了8000-8010端口
- 新建MoFox_bot实例时，主程序端口会自动分配到8011+
- NapCat端口也会相应调整，避免冲突

## 错误处理

- **循环引用问题**：已修复，只保存配置名称而非整个对象
- 端口分配失败：自动扩展搜索范围，支持跨类型分配
- 配置文件不存在：创建默认配置
- 权限不足：提示用户手动处理
- 实例运行中：确认后停止再删除
- 配置选择无效：重新显示选择界面

## 测试验证

创建了测试脚本 `test_port_manager.py` 验证：
- 基本端口功能
- 文件存在性
- 语法正确性
- 导入依赖

## 扩展性

- 支持更多实例类型（通过扩展端口分配策略）
- 支持自定义端口范围
- 支持配置文件模板
- 支持实例导入/导出
- 支持端口使用统计和优化建议

## 总结

该实例多开功能完全满足了用户需求：
- ✅ UI动态切换（运行实例 → 实例多开）
- ✅ 端口自动管理和冲突检测
- ✅ 配置文件自动修改
- ✅ **支持MaiBot和MoFox_bot两种类型混用**
- ✅ **灵活的配置选择（可选择任意已有配置）**
- ✅ **实时端口使用状态显示**
- ✅ **循环引用问题已修复**
- ✅ 完整的实例生命周期管理
- ✅ 良好的错误处理和用户体验

功能已完全集成到现有启动器中，可以立即使用。用户现在可以：
1. 选择任意已有配置创建多开实例
2. 同时运行MaiBot和MoFox_bot实例
3. 享受智能的端口冲突处理
4. 实时查看端口使用状态
5. 避免循环引用导致的配置保存问题

## 修复记录

### v1.1 - 循环引用问题修复
- **问题**：保存多开实例配置时出现"Circular reference detected"错误
- **原因**：直接存储整个配置对象导致循环引用
- **解决**：只保存配置名称，通过方法动态获取配置对象
- **影响**：解决了配置保存失败的问题，提高了系统稳定性